import { GoogleCalendarConnector } from '../connectors/google-calendar-connector';
import { 
  TrainingScheduleTemplate, 
  MedicalScheduleTemplate, 
  BulkEventCreationRequest, 
  CalendarEventInput,
  CalendarServiceResponse,
  CalendarEventOutput
} from '../types/google-calendar-types';
import { log } from '../utils/logger';

export class CalendarTrainingService {
  private calendarConnector: GoogleCalendarConnector;

  constructor(calendarConnector: GoogleCalendarConnector) {
    this.calendarConnector = calendarConnector;
  }

  /**
   * ClariVein ì‹œìˆ  í›„ í›ˆë ¨ ì¼ì • í…œí”Œë¦¿
   */
  private getTrainingTemplates(): TrainingScheduleTemplate[] {
    return [
      // 1-2ì£¼ì°¨: ì €ì¶©ê²© ìœ ì‚°ì†Œ ë‹¨ê³„
      {
        phase: 'ì €ì¶©ê²©ìœ ì‚°ì†Œ',
        daysSinceOperation: 8,
        title: 'ClariVein íšŒë³µ - ì €ì¶©ê²© ìœ ì‚°ì†Œ ì‹œì‘',
        duration: 60,
        activities: ['ê³ ì •ì‹ ìì „ê±° 15ë¶„ (ë‚®ì€ ê°•ë„)', 'ìƒì²´ ìŠ¤íŠ¸ë ˆì¹­ 10ë¶„', 'ì••ë°• ìŠ¤íƒ€í‚¹ ì°©ìš© í™•ì¸', 'ì¢…ì•„ë¦¬ ìƒíƒœ ì²´í¬'],
        notes: 'ì²« ìš´ë™ ì¬ê°œ, ë¬´ë¦¬í•˜ì§€ ë§ê³  ëª¸ ìƒíƒœ í™•ì¸',
        checkpoints: ['ì••ë°• ìŠ¤íƒ€í‚¹ ì°©ìš©', 'ì¢…ì•„ë¦¬ ì••í†µ ì²´í¬', 'ë¶€ì¢… ìƒíƒœ í™•ì¸']
      },
      {
        phase: 'ì €ì¶©ê²©ìœ ì‚°ì†Œ',
        daysSinceOperation: 9,
        title: 'ClariVein íšŒë³µ - ê±·ê¸° + ìì „ê±°',
        duration: 60,
        activities: ['ë¹ ë¥¸ ê±·ê¸° 20ë¶„', 'ê³ ì •ì‹ ìì „ê±° 10ë¶„', 'ì½”ì–´ ìš´ë™ (ê°€ë²¼ìš´ í”Œë­í¬ 2ì„¸íŠ¸)', 'ì¦ìƒ ëª¨ë‹ˆí„°ë§'],
        notes: 'ìš´ë™ ê°•ë„ ì•½ê°„ ì¦ê°€, ì••ë°• ìŠ¤íƒ€í‚¹ ì§€ì† ì°©ìš©',
        checkpoints: ['ìš´ë™ ì¤‘ í†µì¦ ì²´í¬', 'ì••ë°• ì°©ìš© ìƒíƒœ', 'ì¢…ì•„ë¦¬ ë°˜ì‘ ê´€ì°°']
      },
      {
        phase: 'ì €ì¶©ê²©ìœ ì‚°ì†Œ',
        daysSinceOperation: 10,
        title: 'ClariVein íšŒë³µ - ì¼ë¦½í‹°ì»¬ ë„ì…',
        duration: 60,
        activities: ['ì¼ë¦½í‹°ì»¬ 15ë¶„ (ë‚®ì€ ê°•ë„)', 'ìƒì²´ ê·¼ë ¥ ìš´ë™ 15ë¶„', 'ìŠ¤íŠ¸ë ˆì¹­ 10ë¶„', 'ì••ë°• ìŠ¤íƒ€í‚¹ ìƒíƒœ í™•ì¸'],
        notes: 'ìƒˆë¡œìš´ ìš´ë™ ê¸°êµ¬ ë„ì…, ë‹¤ë¦¬ ë°˜ì‘ ì£¼ì˜ ê¹Šê²Œ ê´€ì°°',
        checkpoints: ['ìƒˆë¡œìš´ ìš´ë™ ì ì‘ë„', 'ë‹¤ë¦¬ í”¼ë¡œë„', 'ì••ë°• íš¨ê³¼']
      },
      {
        phase: 'ì €ì¶©ê²©ìœ ì‚°ì†Œ',
        daysSinceOperation: 14,
        title: 'ClariVein íšŒë³µ - 2ì£¼ì°¨ ë§ˆë¬´ë¦¬',
        duration: 60,
        activities: ['ê³ ì •ì‹ ìì „ê±° 25ë¶„', 'ìƒì²´ ê·¼ë ¥ ìš´ë™', 'ë‹¤ìŒ ë‹¨ê³„ ì¤€ë¹„ ì ê²€', 'ì´ˆìŒíŒŒ ê²€ì‚¬ ì˜ˆì•½ í™•ì¸'],
        notes: '2ì£¼ì°¨ ì™„ë£Œ! ì´ˆìŒíŒŒ ê²€ì‚¬ ì˜ˆì•½ í•„ìˆ˜ í™•ì¸',
        checkpoints: ['2ì£¼ì°¨ ìƒíƒœ í‰ê°€', 'ì´ˆìŒíŒŒ ê²€ì‚¬ ì¤€ë¹„', 'ë‹¤ìŒ ë‹¨ê³„ ê³„íš'],
        isImportantMilestone: true
      },
      // 3-4ì£¼ì°¨: ì¡°ê¹… ë„ì… ë‹¨ê³„
      {
        phase: 'ì¡°ê¹…ë„ì…',
        daysSinceOperation: 22,
        title: 'ClariVein íšŒë³µ - ì²« ì¡°ê¹… ì‹œë„',
        duration: 60,
        activities: ['ì›Œë°ì—… ê±·ê¸° 10ë¶„', 'ì¡°ê¹… 5ë¶„ + ê±·ê¸° 2ë¶„ (2íšŒ ë°˜ë³µ)', 'ì¿¨ë‹¤ìš´ ê±·ê¸° 10ë¶„', 'ì••ë°• ìŠ¬ë¦¬ë¸Œ ì°©ìš© í•„ìˆ˜'],
        notes: 'ì²« ì¡°ê¹… ì‹œë„, ë¬´ë¦¬í•˜ì§€ ë§ê³  ì ì§„ì  ì§„í–‰',
        checkpoints: ['ì¡°ê¹… ì¤‘ í†µì¦', 'ì••ë°• ìŠ¬ë¦¬ë¸Œ íš¨ê³¼', 'íšŒë³µ ë°˜ì‘'],
        isImportantMilestone: true
      },
      {
        phase: 'ì¡°ê¹…ë„ì…',
        daysSinceOperation: 28,
        title: 'ClariVein íšŒë³µ - 1ê°œì›” í‰ê°€',
        duration: 60,
        activities: ['ì¡°ê¹… í…ŒìŠ¤íŠ¸ (15ë¶„ ì—°ì†)', 'ì „ë°˜ì  ìƒíƒœ ì ê²€', 'ì˜ë£Œì§„ ìƒë‹´ ë° ë‹¤ìŒ ë‹¨ê³„ ê³„íš'],
        notes: '1ê°œì›” ì™„ë£Œ! ì˜ë£Œì§„ ìƒë‹´ìœ¼ë¡œ ë‹¤ìŒ ë‹¨ê³„ ìŠ¹ì¸ ë°›ê¸°',
        checkpoints: ['1ê°œì›” íšŒë³µ ìƒíƒœ', 'ì—°ì† ì¡°ê¹… ê°€ëŠ¥ì„±', 'ì˜ë£Œì§„ ìŠ¹ì¸'],
        isImportantMilestone: true
      },
      // 5-6ì£¼ì°¨: ì—°ì† ë‹¬ë¦¬ê¸° ë‹¨ê³„
      {
        phase: 'ì—°ì†ë‹¬ë¦¬ê¸°',
        daysSinceOperation: 35,
        title: 'ClariVein íšŒë³µ - ì¥ê±°ë¦¬ í…ŒìŠ¤íŠ¸',
        duration: 90,
        activities: ['ì›Œë°ì—… ê±·ê¸° 10ë¶„', 'ì—°ì† ì¡°ê¹… 30ë¶„', 'ì¿¨ë‹¤ìš´ ê±·ê¸° 15ë¶„', '5ì£¼ì°¨ ìƒíƒœ í‰ê°€'],
        notes: '5ì£¼ì°¨ ì™„ë£Œ, ì—°ì† ë‹¬ë¦¬ê¸° 30ë¶„ ë‹¬ì„±',
        checkpoints: ['ì¥ê±°ë¦¬ ì§€êµ¬ë ¥', 'ë‹¤ë¦¬ ìƒíƒœ', 'ì „ë°˜ì  ì»¨ë””ì…˜'],
        isImportantMilestone: true
      },
      // 7-8ì£¼ì°¨: êµ¬ì¡°í™”ëœ ìš´ë™ ë‹¨ê³„
      {
        phase: 'êµ¬ì¡°í™”ìš´ë™',
        daysSinceOperation: 49,
        title: 'ClariVein íšŒë³µ - ì¥ê±°ë¦¬ ëŸ°',
        duration: 120,
        activities: ['ì›Œë°ì—… ì¡°ê¹… 10ë¶„', 'ì—°ì† ë‹¬ë¦¬ê¸° 40ë¶„', 'ì¿¨ë‹¤ìš´ ê±·ê¸° 15ë¶„', '7ì£¼ì°¨ ìƒíƒœ í‰ê°€'],
        notes: '7ì£¼ì°¨ ì™„ë£Œ, êµ¬ì¡°í™”ëœ ìš´ë™ ë‹¨ê³„ ë§ˆë¬´ë¦¬',
        checkpoints: ['ê³ ê°•ë„ ìš´ë™ ì ì‘', 'ì¥ê±°ë¦¬ ëŠ¥ë ¥', 'ë‹¤ìŒ ë‹¨ê³„ ì¤€ë¹„'],
        isImportantMilestone: true
      },
      // 9-12ì£¼ì°¨: ë§ˆë¼í†¤ í›ˆë ¨ ë‹¨ê³„
      {
        phase: 'ë§ˆë¼í†¤í›ˆë ¨',
        daysSinceOperation: 57,
        title: 'ë§ˆë¼í†¤ í›ˆë ¨ - ë³¸ê²© ì‹œì‘',
        duration: 90,
        activities: ['ì›Œë°ì—… ì¡°ê¹… 15ë¶„', 'í…œí¬ ëŸ° 15ë¶„', 'ì¿¨ë‹¤ìš´ ì¡°ê¹… 10ë¶„', 'ìŠ¤íŠ¸ë ˆì¹­ 10ë¶„'],
        notes: 'ë§ˆë¼í†¤ í›ˆë ¨ ë³¸ê²© ì‹œì‘',
        checkpoints: ['í…œí¬ ëŸ° ì ì‘', 'ë§ˆë¼í†¤ í˜ì´ìŠ¤', 'ì§€êµ¬ë ¥ í–¥ìƒ'],
        isImportantMilestone: true
      },
      {
        phase: 'ë§ˆë¼í†¤í›ˆë ¨',
        daysSinceOperation: 84,
        title: 'ë§ˆë¼í†¤ ì¤€ë¹„ - ìµœì¢… í‰ê°€',
        duration: 90,
        activities: ['ê°€ë²¼ìš´ ì¡°ê¹… 30ë¶„', 'ì „ì‹  ìŠ¤íŠ¸ë ˆì¹­ 20ë¶„', 'ë§ˆë¼í†¤ ì°¸ê°€ ìµœì¢… ê²°ì •', 'ë“€í”Œë ‰ìŠ¤ ìŠ¤ìº” ì˜ˆì•½'],
        notes: '12ì£¼ì°¨ ì™„ë£Œ! ë§ˆë¼í†¤ ì°¸ê°€ ìµœì¢… ìŠ¹ì¸',
        checkpoints: ['ìµœì¢… ìƒíƒœ í‰ê°€', 'ë§ˆë¼í†¤ ì¤€ë¹„ë„', 'ì˜ë£Œì§„ ìµœì¢… ìŠ¹ì¸'],
        isImportantMilestone: true
      }
    ];
  }

  /**
   * ì˜ë£Œ ì¼ì • í…œí”Œë¦¿
   */
  private getMedicalTemplates(): MedicalScheduleTemplate[] {
    return [
      {
        type: 'ultrasound',
        daysSinceOperation: 14,
        title: 'ì´ˆìŒíŒŒ ê²€ì‚¬',
        description: '2ì£¼ì°¨ ì™„ë£Œ í›„ ì´ˆìŒíŒŒ ê²€ì‚¬ë¡œ ì •ë§¥ íì‡„ ìƒíƒœ í™•ì¸',
        duration: 60,
        location: 'ë³‘ì›',
        isRequired: true,
        reminders: [
          { method: 'popup', minutes: 1440 }, // í•˜ë£¨ ì „
          { method: 'popup', minutes: 120 }   // 2ì‹œê°„ ì „
        ]
      },
      {
        type: 'consultation',
        daysSinceOperation: 28,
        title: '1ê°œì›” ì˜ë£Œì§„ ìƒë‹´',
        description: '4ì£¼ì°¨ ì™„ë£Œ í›„ ì „ë°˜ì  íšŒë³µ ìƒíƒœ ì ê²€ ë° ë‹¤ìŒ ë‹¨ê³„ ê³„íš ìˆ˜ë¦½',
        duration: 60,
        location: 'ë³‘ì›',
        isRequired: true,
        reminders: [
          { method: 'popup', minutes: 1440 }, // í•˜ë£¨ ì „
          { method: 'popup', minutes: 60 }    // 1ì‹œê°„ ì „
        ]
      },
      {
        type: 'evaluation',
        daysSinceOperation: 56,
        title: '8ì£¼ì°¨ ìƒíƒœ í‰ê°€',
        description: 'êµ¬ì¡°í™”ëœ ìš´ë™ ë‹¨ê³„ ì™„ë£Œ í›„ ë§ˆë¼í†¤ í›ˆë ¨ ì‹œì‘ ê°€ëŠ¥ ì—¬ë¶€ í‰ê°€',
        duration: 60,
        location: 'ë³‘ì›',
        isRequired: true,
        reminders: [
          { method: 'popup', minutes: 1440 }, // í•˜ë£¨ ì „
          { method: 'popup', minutes: 60 }    // 1ì‹œê°„ ì „
        ]
      },
      {
        type: 'scan',
        daysSinceOperation: 84,
        title: 'ìµœì¢… ë“€í”Œë ‰ìŠ¤ ìŠ¤ìº”',
        description: 'ë§ˆë¼í†¤ ì°¸ê°€ ì „ ìµœì¢… í˜ˆê´€ ìƒíƒœ í™•ì¸ ë° ìŠ¹ì¸',
        duration: 60,
        location: 'ë³‘ì›',
        isRequired: true,
        reminders: [
          { method: 'popup', minutes: 1440 }, // í•˜ë£¨ ì „
          { method: 'popup', minutes: 60 }    // 1ì‹œê°„ ì „
        ]
      }
    ];
  }

  /**
   * ë‚ ì§œ ê³„ì‚° ìœ í‹¸ë¦¬í‹°
   */
  private addDaysToDate(date: Date, days: number): Date {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  }

  /**
   * ì‹œê°„ ë¬¸ìì—´ì„ Date ê°ì²´ë¡œ ë³€í™˜
   */
  private createDateTime(date: Date, timeString: string): string {
    const [hours, minutes] = timeString.split(':').map(Number);
    const dateTime = new Date(date);
    dateTime.setHours(hours, minutes, 0, 0);
    return dateTime.toISOString();
  }

  /**
   * í›ˆë ¨ ì¼ì • ìƒì„±
   */
  async createTrainingSchedule(request: BulkEventCreationRequest): Promise<CalendarServiceResponse<CalendarEventOutput[]>> {
    try {
      const operationDate = new Date(request.operationDate);
      const templates = this.getTrainingTemplates();
      const medicalTemplates = this.getMedicalTemplates();
      const createdEvents: CalendarEventOutput[] = [];

      // í›ˆë ¨ ì¼ì • ìƒì„±
      for (const template of templates) {
        // í˜„ì¬ ìˆ˜ìˆ  í›„ ì¼ìˆ˜ë³´ë‹¤ ë¯¸ë˜ ì¼ì •ë§Œ ìƒì„±
        if (template.daysSinceOperation >= request.currentDaysSinceOperation) {
          const eventDate = this.addDaysToDate(operationDate, template.daysSinceOperation);
          
          // ì£¼ë§ ì œì™¸ ì˜µì…˜ í™•ì¸
          if (!request.includeWeekends && (eventDate.getDay() === 0 || eventDate.getDay() === 6)) {
            continue;
          }

          const startDateTime = this.createDateTime(eventDate, request.trainingTime);
          const endDateTime = this.createDateTime(eventDate, 
            this.addMinutesToTime(request.trainingTime, template.duration));

          const eventData: CalendarEventInput = {
            title: template.title,
            description: this.formatTrainingDescription(template),
            startDateTime: startDateTime,
            endDateTime: endDateTime,
            location: this.getLocationForPhase(template.phase, request.location),
            calendarId: request.calendarId,
            reminders: {
              useDefault: false,
              overrides: [
                { method: 'popup', minutes: 30 }
              ]
            }
          };

          const result = await this.calendarConnector.createEvent(eventData);
          if (result.success && result.data) {
            createdEvents.push(result.data);
            log.info(`Created training event: ${template.title} on ${eventDate.toDateString()}`);
          } else {
            log.error(`Failed to create training event: ${template.title}`, result.error);
          }
        }
      }

      // ì˜ë£Œ ì¼ì • ìƒì„±
      if (request.includeMedicalSchedule) {
        for (const template of medicalTemplates) {
          if (template.daysSinceOperation >= request.currentDaysSinceOperation) {
            const eventDate = this.addDaysToDate(operationDate, template.daysSinceOperation);
            const startDateTime = this.createDateTime(eventDate, '14:00'); // ì˜¤í›„ 2ì‹œ ê¸°ë³¸
            const endDateTime = this.createDateTime(eventDate, 
              this.addMinutesToTime('14:00', template.duration));

            const eventData: CalendarEventInput = {
              title: template.title,
              description: template.description,
              startDateTime: startDateTime,
              endDateTime: endDateTime,
              location: request.location.hospital || template.location,
              calendarId: request.calendarId,
              reminders: {
                useDefault: false,
                overrides: template.reminders
              }
            };

            const result = await this.calendarConnector.createEvent(eventData);
            if (result.success && result.data) {
              createdEvents.push(result.data);
              log.info(`Created medical event: ${template.title} on ${eventDate.toDateString()}`);
            } else {
              log.error(`Failed to create medical event: ${template.title}`, result.error);
            }
          }
        }
      }

      return {
        success: true,
        data: createdEvents
      };
    } catch (error) {
      log.error('Failed to create training schedule', error);
      return {
        success: false,
        error: {
          code: 'SCHEDULE_CREATE_FAILED',
          message: 'Failed to create training schedule',
          details: error
        }
      };
    }
  }

  /**
   * í›ˆë ¨ ì„¤ëª… í¬ë§·íŒ…
   */
  private formatTrainingDescription(template: TrainingScheduleTemplate): string {
    let description = `ğŸ“… ìˆ˜ìˆ  í›„ ${template.daysSinceOperation}ì¼ì§¸ - ${template.phase} ë‹¨ê³„\n\n`;
    description += `ğŸƒâ€â™‚ï¸ ìš´ë™ ë‚´ìš©:\n`;
    template.activities.forEach(activity => {
      description += `â€¢ ${activity}\n`;
    });
    description += `\nğŸ“ ì£¼ì˜ì‚¬í•­: ${template.notes}\n\n`;
    description += `âœ… ì²´í¬í¬ì¸íŠ¸:\n`;
    template.checkpoints.forEach(checkpoint => {
      description += `â€¢ ${checkpoint}\n`;
    });
    
    if (template.isImportantMilestone) {
      description += `\nâ­ ì¤‘ìš” ë§ˆì¼ìŠ¤í†¤: ì´ ë‹¨ê³„ ì™„ë£Œ í›„ ë‹¤ìŒ ë‹¨ê³„ ì§„í–‰ ê°€ëŠ¥\n`;
    }
    
    description += `\nâš ï¸ ì•ˆì „ ìˆ˜ì¹™: ëª¸ ìƒíƒœ ë³€í™” ì‹œ ì¦‰ì‹œ ìš´ë™ ì¤‘ë‹¨í•˜ê³  ì˜ë£Œì§„ ìƒë‹´`;
    
    return description;
  }

  /**
   * ë‹¨ê³„ë³„ ìš´ë™ ì¥ì†Œ ê²°ì •
   */
  private getLocationForPhase(phase: string, locations: BulkEventCreationRequest['location']): string {
    switch (phase) {
      case 'ì €ì¶©ê²©ìœ ì‚°ì†Œ':
      case 'ì¡°ê¹…ë„ì…':
        return locations.gym || 'í—¬ìŠ¤ì¥';
      case 'ì—°ì†ë‹¬ë¦¬ê¸°':
      case 'êµ¬ì¡°í™”ìš´ë™':
      case 'ë§ˆë¼í†¤í›ˆë ¨':
        return locations.park || 'ê³µì›';
      default:
        return locations.gym || 'í—¬ìŠ¤ì¥';
    }
  }

  /**
   * ì‹œê°„ì— ë¶„ ì¶”ê°€
   */
  private addMinutesToTime(timeString: string, minutes: number): string {
    const [hours, mins] = timeString.split(':').map(Number);
    const totalMinutes = hours * 60 + mins + minutes;
    const newHours = Math.floor(totalMinutes / 60) % 24;
    const newMins = totalMinutes % 60;
    return `${newHours.toString().padStart(2, '0')}:${newMins.toString().padStart(2, '0')}`;
  }

  /**
   * íŠ¹ì • ë‚ ì§œì˜ í›ˆë ¨ ì¼ì • ì¡°íšŒ
   */
  async getTrainingScheduleForDate(date: string, calendarId?: string): Promise<CalendarServiceResponse<CalendarEventOutput[]>> {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);
    
    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);

    return await this.calendarConnector.getEvents({
      calendarId: calendarId,
      timeMin: startOfDay.toISOString(),
      timeMax: endOfDay.toISOString(),
      query: 'ClariVein',
      orderBy: 'startTime'
    });
  }

  /**
   * í›ˆë ¨ ì¼ì • ì™„ë£Œ í‘œì‹œ
   */
  async markTrainingComplete(eventId: string, notes?: string, calendarId: string = 'primary'): Promise<CalendarServiceResponse<CalendarEventOutput>> {
    try {
      // ì´ë²¤íŠ¸ ì¡°íšŒ
      const events = await this.calendarConnector.getEvents({
        calendarId: calendarId,
        maxResults: 1
      });

      if (!events.success || !events.data) {
        return {
          success: false,
          error: {
            code: 'EVENT_NOT_FOUND',
            message: 'Event not found'
          }
        };
      }

      const event = events.data.find(e => e.id === eventId);
      if (!event) {
        return {
          success: false,
          error: {
            code: 'EVENT_NOT_FOUND',
            message: 'Event not found'
          }
        };
      }

      // ì œëª©ì— ì™„ë£Œ í‘œì‹œ ì¶”ê°€
      const updatedTitle = event.title.startsWith('âœ…') ? event.title : `âœ… ${event.title}`;
      
      // ì„¤ëª…ì— ì™„ë£Œ ë…¸íŠ¸ ì¶”ê°€
      let updatedDescription = event.description || '';
      if (notes) {
        updatedDescription += `\n\nğŸ“ ì™„ë£Œ ë…¸íŠ¸ (${new Date().toLocaleDateString()}):\n${notes}`;
      }

      return await this.calendarConnector.updateEvent(eventId, {
        title: updatedTitle,
        description: updatedDescription
      }, calendarId);
    } catch (error) {
      log.error('Failed to mark training complete', error);
      return {
        success: false,
        error: {
          code: 'MARK_COMPLETE_FAILED',
          message: 'Failed to mark training as complete',
          details: error
        }
      };
    }
  }
} 